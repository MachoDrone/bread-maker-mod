#!/bin/bash
# lib/mixer-provision.sh — Post-boot provisioning pipeline
# SSHes into VM, waits for cloud-init, SCPs spoof files, builds fake image, verifies
#
# Version: 0.03.0

PROVISION_SSH_TIMEOUT=300
PROVISION_SSH_INTERVAL=10
PROVISION_CLOUDINIT_TIMEOUT=600
PROVISION_NOSANA_TIMEOUT=120

# --- Wait for SSH to become available ---
mixer_provision_wait_ssh() {
    local ip="$1"
    local timeout="${2:-${PROVISION_SSH_TIMEOUT}}"

    log_step "Waiting for SSH on ${ip}..."
    local elapsed=0
    local interval="${PROVISION_SSH_INTERVAL}"

    while [ "${elapsed}" -lt "${timeout}" ]; do
        if mixer_ssh "${ip}" "true" >/dev/null 2>&1; then
            log_info "SSH ready on ${ip} (${elapsed}s)"
            return 0
        fi
        sleep "${interval}"
        elapsed=$((elapsed + interval))
        # Back off: increase interval up to 30s
        if [ "${interval}" -lt 30 ]; then
            interval=$((interval + 5))
        fi
    done

    log_error "SSH timeout after ${timeout}s on ${ip}"
    return 1
}

# --- Wait for cloud-init to complete ---
mixer_provision_wait_cloudinit() {
    local ip="$1"
    local timeout="${2:-${PROVISION_CLOUDINIT_TIMEOUT}}"

    log_step "Waiting for cloud-init to complete..."
    local elapsed=0

    while [ "${elapsed}" -lt "${timeout}" ]; do
        local status
        status=$(mixer_ssh "${ip}" "cloud-init status 2>/dev/null | awk '{print \$NF}'" 2>/dev/null || true)

        if [ "${status}" = "done" ]; then
            log_info "Cloud-init complete (${elapsed}s)"
            return 0
        elif [ "${status}" = "error" ]; then
            log_warn "Cloud-init finished with errors"
            mixer_ssh "${ip}" "cloud-init status --long 2>/dev/null | tail -5" 2>/dev/null || true
            return 0  # Continue provisioning despite cloud-init errors
        fi

        sleep 15
        elapsed=$((elapsed + 15))
    done

    log_error "Cloud-init timeout after ${timeout}s"
    return 1
}

# --- Wait for VM to come back after reboot ---
mixer_provision_wait_reboot() {
    local ip="$1"

    log_step "Waiting for post-reboot SSH..."
    # Give the VM time to start shutting down
    sleep 15

    mixer_provision_wait_ssh "${ip}" 180
}

# --- Check nvidia-smi works ---
mixer_provision_check_nvidia() {
    local ip="$1"

    log_step "Checking nvidia-smi..."
    local output
    output=$(mixer_ssh "${ip}" "nvidia-smi --query-gpu=name --format=csv,noheader 2>/dev/null" 2>/dev/null || true)

    if [ -n "${output}" ]; then
        log_info "GPU detected: ${output}"
        return 0
    else
        log_warn "nvidia-smi not available (VM may not have GPU assigned)"
        return 1
    fi
}

# --- Generate per-VM fake-fast script ---
mixer_provision_generate_fake_fast() {
    local vmid="$1"
    local output="/tmp/mixer-fake-fast-${vmid}"

    local download upload latency
    download=$(mixer_vm_state_get "${vmid}" "download_speed")
    upload=$(mixer_vm_state_get "${vmid}" "upload_speed")
    latency=$(mixer_vm_state_get "${vmid}" "latency")

    cat > "${output}" <<FAKESCRIPT
#!/bin/bash
# fake-fast — Drop-in replacement for Netflix fast-cli
# Generated by mixer for VM ${vmid}

echo '{"downloadSpeed":${download},"uploadSpeed":${upload},"latency":${latency}}'
FAKESCRIPT

    chmod +x "${output}"
    echo "${output}"
}

# --- Generate per-VM cuda-check wrapper ---
mixer_provision_generate_cuda_wrapper() {
    local vmid="$1"
    local output="/tmp/mixer-cuda-wrapper-${vmid}.sh"

    local gpu_uuid
    gpu_uuid=$(mixer_vm_state_get "${vmid}" "gpu_uuid")

    cat > "${output}" <<'WRAPPERSCRIPT'
#!/bin/bash
# cuda-check-wrapper.sh — Drop-in replacement for /cuda_check
# Generated by mixer for VM VMID_PLACEHOLDER

FAKE_UUID="UUID_PLACEHOLDER"

# Run real binary, pass through all args
OUTPUT=$(/cuda_check_real "$@" 2>&1)
EXIT_CODE=$?

if [ $EXIT_CODE -ne 0 ]; then
    echo "$OUTPUT"
    exit $EXIT_CODE
fi

# Patch all GPU UUIDs in JSON output
echo "$OUTPUT" | jq --arg fake "$FAKE_UUID" \
    'walk(if type == "string" and startswith("GPU-") then $fake else . end)'
WRAPPERSCRIPT

    # Replace placeholders
    sed -i "s|VMID_PLACEHOLDER|${vmid}|g" "${output}"
    sed -i "s|UUID_PLACEHOLDER|${gpu_uuid}|g" "${output}"

    chmod +x "${output}"
    echo "${output}"
}

# --- Generate Dockerfile.stats for this VM ---
mixer_provision_generate_dockerfile() {
    local vmid="$1"
    local output="/tmp/mixer-Dockerfile-stats-${vmid}"

    cat > "${output}" <<'DOCKERFILE'
FROM nosana/stats:v1.2.1

# Speed spoof: replace fast binary
COPY fake-fast /usr/local/bin/fast
RUN chmod +x /usr/local/bin/fast

# GPU UUID spoof: rename real binary, install wrapper
RUN mv /cuda_check /cuda_check_real
COPY cuda-check-wrapper.sh /cuda_check
RUN chmod +x /cuda_check
DOCKERFILE

    echo "${output}"
}

# --- SCP spoof files to VM ---
mixer_provision_scp_files() {
    local vmid="$1"
    local ip="$2"

    log_step "Generating per-VM spoof files..."

    local fake_fast cuda_wrapper dockerfile
    fake_fast=$(mixer_provision_generate_fake_fast "${vmid}")
    cuda_wrapper=$(mixer_provision_generate_cuda_wrapper "${vmid}")
    dockerfile=$(mixer_provision_generate_dockerfile "${vmid}")

    log_step "Copying spoof files to VM ${vmid}..."

    # Create build dir on VM
    mixer_ssh "${ip}" "mkdir -p /tmp/mixer-build"

    mixer_scp "${fake_fast}" "${ip}" "/tmp/mixer-build/fake-fast"
    mixer_scp "${cuda_wrapper}" "${ip}" "/tmp/mixer-build/cuda-check-wrapper.sh"
    mixer_scp "${dockerfile}" "${ip}" "/tmp/mixer-build/Dockerfile.stats"

    # Clean up local temp files
    rm -f "${fake_fast}" "${cuda_wrapper}" "${dockerfile}"

    log_info "Spoof files copied to VM ${vmid}"
}

# --- Build fake stats image on VM ---
mixer_provision_build_image() {
    local ip="$1"

    log_step "Building fake stats image on VM..."

    local output
    output=$(mixer_ssh "${ip}" "cd /tmp/mixer-build && \
        docker build -t nosana/stats:v1.2.1 -f Dockerfile.stats . --quiet 2>&1" 2>&1)

    if [ $? -ne 0 ]; then
        log_error "Failed to build fake stats image"
        echo "${output}" | tail -5
        return 1
    fi

    # Tag with registry prefix
    mixer_ssh "${ip}" "docker tag nosana/stats:v1.2.1 registry.hub.docker.com/nosana/stats:v1.2.1" 2>/dev/null

    log_info "Fake stats image built"
}

# --- Start nosana and inject fake image ---
mixer_provision_start_nosana() {
    local ip="$1"

    log_step "Starting nosana on VM..."

    # Run nosana start.sh in background via SSH
    mixer_ssh "${ip}" "nohup bash -c 'bash <(wget -qO- https://nosana.com/start.sh)' > /tmp/nosana-start.log 2>&1 &"

    # Wait for podman container to appear
    log_step "Waiting for podman container..."
    local elapsed=0
    while [ "${elapsed}" -lt "${PROVISION_NOSANA_TIMEOUT}" ]; do
        local podman_running
        podman_running=$(mixer_ssh "${ip}" "docker inspect podman >/dev/null 2>&1 && echo yes || echo no" 2>/dev/null)

        if [ "${podman_running}" = "yes" ]; then
            sleep 5  # Give it a moment to fully initialize
            log_info "Podman container is running (${elapsed}s)"
            break
        fi
        sleep 10
        elapsed=$((elapsed + 10))
    done

    if [ "${elapsed}" -ge "${PROVISION_NOSANA_TIMEOUT}" ]; then
        log_warn "Podman container not ready after ${PROVISION_NOSANA_TIMEOUT}s"
        log_warn "Inject manually later: mixer provision ${vmid}"
        return 1
    fi

    # Inject fake image into podman
    mixer_provision_inject_image "${ip}"
}

# --- Inject fake stats image into running podman container ---
mixer_provision_inject_image() {
    local ip="$1"

    log_step "Injecting fake stats image into podman..."

    mixer_ssh "${ip}" "docker save registry.hub.docker.com/nosana/stats:v1.2.1 | \
        docker exec -i podman podman load && \
        docker exec podman podman tag \
            registry.hub.docker.com/nosana/stats:v1.2.1 \
            docker.io/nosana/stats:v1.2.1" 2>/dev/null

    if [ $? -eq 0 ]; then
        log_info "Fake stats image injected into podman"
    else
        log_warn "Image injection failed — may need manual injection"
        return 1
    fi
}

# --- Verify spoofing works ---
mixer_provision_verify() {
    local vmid="$1"
    local ip="$2"

    log_header "Verification — VM ${vmid}"
    echo ""

    local expected_model
    expected_model=$(mixer_vm_state_get "${vmid}" "model_string")
    local expected_board
    expected_board=$(mixer_vm_state_get "${vmid}" "board_model")
    local expected_dl
    expected_dl=$(mixer_vm_state_get "${vmid}" "download_speed")

    # CPU model
    local actual_model
    actual_model=$(mixer_ssh "${ip}" "grep 'model name' /proc/cpuinfo | head -1 | cut -d: -f2 | xargs" 2>/dev/null)
    if [ "${actual_model}" = "${expected_model}" ]; then
        log_info "CPU model: ${actual_model}"
    else
        log_warn "CPU model mismatch: got '${actual_model}', expected '${expected_model}'"
    fi

    # Board name
    local actual_board
    actual_board=$(mixer_ssh "${ip}" "cat /sys/class/dmi/id/board_name 2>/dev/null" 2>/dev/null)
    if echo "${actual_board}" | grep -qi "${expected_board}"; then
        log_info "Board: ${actual_board}"
    else
        log_warn "Board mismatch: got '${actual_board}', expected '${expected_board}'"
    fi

    # BIOS vendor
    local actual_bios
    actual_bios=$(mixer_ssh "${ip}" "cat /sys/class/dmi/id/bios_vendor 2>/dev/null" 2>/dev/null)
    if echo "${actual_bios}" | grep -qi "American Megatrends"; then
        log_info "BIOS vendor: ${actual_bios}"
    else
        log_warn "BIOS vendor: ${actual_bios} (expected AMI)"
    fi

    # systemd-detect-virt
    local detect_virt
    detect_virt=$(mixer_ssh "${ip}" "systemd-detect-virt 2>/dev/null" 2>/dev/null || true)
    if [ "${detect_virt}" = "none" ]; then
        log_info "systemd-detect-virt: none"
    else
        log_warn "systemd-detect-virt: ${detect_virt} (expected 'none')"
    fi

    # NIC driver
    local nic_driver
    nic_driver=$(mixer_ssh "${ip}" "ethtool -i eth0 2>/dev/null | grep driver | awk '{print \$2}'" 2>/dev/null)
    if [ "${nic_driver}" = "e1000e" ]; then
        log_info "NIC driver: e1000e"
    else
        log_warn "NIC driver: ${nic_driver} (expected e1000e)"
    fi

    # Disk model
    local disk_model
    disk_model=$(mixer_ssh "${ip}" "lsblk -o MODEL -dn 2>/dev/null | head -1 | xargs" 2>/dev/null)
    log_info "Disk model: ${disk_model:-unknown}"

    # GPU (if assigned)
    local has_gpu
    has_gpu=$(mixer_vm_state_get "${vmid}" "has_gpu" "false")
    if [ "${has_gpu}" = "true" ]; then
        mixer_provision_check_nvidia "${ip}"
    fi

    # qemu-guest-agent (should be disabled)
    local qga_count
    qga_count=$(mixer_ssh "${ip}" "ps aux 2>/dev/null | grep -c '[q]emu-guest-agent'" 2>/dev/null || echo "0")
    if [ "${qga_count}" = "0" ]; then
        log_info "qemu-guest-agent: disabled"
    else
        log_warn "qemu-guest-agent: still running (${qga_count} processes)"
    fi

    echo ""
}

# --- Full provisioning pipeline ---
mixer_provision_vm() {
    local vmid="$1"

    local state
    state=$(mixer_vm_state_load "${vmid}" 2>/dev/null)
    if [ -z "${state}" ]; then
        log_error "VM ${vmid} not found in mixer state"
        return 1
    fi

    local ip
    ip=$(echo "${state}" | jq -r '.ip')
    if [ "${ip}" = "dhcp" ] || [ -z "${ip}" ]; then
        log_error "Cannot provision VM with DHCP address. Set static IP or pass --ip to create."
        return 1
    fi

    log_header "Provisioning VM ${vmid} (${ip})"
    echo ""

    # Phase 1: Wait for SSH after initial boot
    mixer_provision_wait_ssh "${ip}" || return 1

    # Phase 2: Wait for cloud-init
    mixer_provision_wait_cloudinit "${ip}" || return 1

    # Phase 3: Wait for reboot (cloud-init triggers reboot for NVIDIA driver)
    mixer_provision_wait_reboot "${ip}" || return 1

    # Phase 4: Verify NVIDIA if GPU assigned
    local has_gpu
    has_gpu=$(mixer_vm_state_get "${vmid}" "has_gpu" "false")
    if [ "${has_gpu}" = "true" ]; then
        mixer_provision_check_nvidia "${ip}" || true
    fi

    # Phase 5: SCP spoof files
    mixer_provision_scp_files "${vmid}" "${ip}"

    # Phase 6: Build fake stats image
    mixer_provision_build_image "${ip}" || return 1

    # Phase 7: Start nosana and inject
    mixer_provision_start_nosana "${ip}" || true

    # Phase 8: Mark as provisioned
    mixer_vm_state_set "${vmid}" "provisioned" "true"

    # Phase 9: Verify
    mixer_provision_verify "${vmid}" "${ip}"

    log_info "Provisioning complete for VM ${vmid}"
}
